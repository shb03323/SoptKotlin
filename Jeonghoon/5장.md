## 람다로 프로그래밍

- **람다** : 다른 함수에 넘길 수 있는 작은 코드 조각
- 코틀린에서 컬렉션 처리를 할 때 람다를 사용

</br>

## 5.1 람다 식과 멤버 참조

1. **람다 소개: 코드 블록을 함수 인자로 넘기기**

   - 람다 식을 사용하면 함수를 선언할 필요가 없고 코드 블록을 직접 함수의 인자로 전달 가능

2. **람다와 컬렉션**

   - 라이브러리 함수와 람다는 환상의 콜라보

   ```kotlin
   data class Person(val name: String, val age: Int)
   
   // 컬렉션 직접 검색
   fun findTheOldest(people: List<Person>) {
       var maxAge = 0
       var theOldest: Person? = null
       for (person in people) {
           if (person.age > maxAge) {
               maxAge = person.age
               theOldest = person
           }
       }
       println(theOldest)
   }
   fun main(args: Array<String>) {
       val people = listOf(Person("Alice", 29), Person("Bob", 31))
       findTheOldest(people)
   }
   
   // 람다를 사용해 컬렉션 검색
   >>> val people = listOf(Person("Alice", 29), Person("Bob", 31))
   >>> println(people.maxBy { it.age })
   Person(name=Bob, age=31)
   ```

   - 자바 컬렉션에 대해 수행하던 대부분의 작업은 람다나 멤버 참조를 인자로 취하는 라이브러리 함수를 통해 개선 가능

3. **람다 식의 문법**

   - 람다는 값처럼 여기저기 전달할 수 있는 동작의 모음

   - 람다를 따로 선언해서 변수에 저장할 수 있지만 함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분

   - 람다에서 화살표(->)가 인자 목록과 람다 본문을 구현

   - 코드의 일부분을 블록으로 둘러싸 실행할 필요가 있다면 `run` 사용

   - `run` : 인자로 받은 람다를 실행해주는 라이브러리

   - 기본 람다 식

     ```kotlin
     people.maxBy({ p: Person -> p.age })
     ```

   - 인자가 단 하나뿐인 경우 굳이 인자에 이름을 붙이지 않아도 됨

   - 람다가 마지막 인자일 때, 람다를 괄호 밖으로 빼낼 수 있음

     ```kotlin
     people.maxBy() { p: Person -> p.age }
     ```

   - 람다가 어떤 함수의 유일한 인자이고 괄호 뒤에 람다를 썼다면 호출 시 빈 괄호를 없애도 됨

     ```kotlin
     people.maxBy { p: Person -> p.age }
     ```

   - 간결하면 가독성이 떨어질 수 있음

   - 로컬 변수처럼 컴파일러는 람다 파라미터의 타입도 추론 가능

   - 람다의 파라미터 이름을 디폴트 이름인 `it`로 바꾸면 람다 식을 더 간단하게 만들 수 있음

   - 람다의 파라미터가 하나뿐이고 그 타입을 컴파일러가 추론할 수 있는 경우 `it`을 바로 쓸 수 있음

     ```kotlin
     people.maxBy { it.age }
     ```

   - 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않으므로 파라미터 타입을 명시해야 함

4. **현재 영역에 있는 변수에 접근**

   - 람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용 가능

     ```kotlin
     fun printMessagesWithPrefix(messages: Collection<String>, prefix: String) {
         messages.forEach {
             println("$prefix $it")
         }
     }
     ```

   - 코틀린 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수 있고 람다 안에서 바깥의 변수를 변경해도 됨

     ```kotlin
     fun printProblemCounts(responses: Collection<String>) {
         var clientErrors = 0
         var serverErrors = 0
         responses.forEach {
             if (it.startsWith("4")) {
                 clientErrors++
             } else if (it.startsWith("5")) {
                 serverErrors++
             }
         }
         println("$clientErrors client errors, $serverErrors server errors")
     }
     ```

     > `prefix`, `clientErrors`, `serverErrors`와 같이 람다 안에서 사용하는 외부 변수를 ''람다가 포획한 변수''라고 부름

   - 기본적으로 함수 안에 정의된 로컬 변수의 생명주기는 함수가 반환되면 끝나지만, 어떤 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장한다면 로컬 변수의 생명주기와 함수의 생명주기가 달라질 수 있음

     > 포획한 변수가 있는 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있음
     >
     > - 파이널 변수를 포획한 경우 : 람다 코드를 변수 값과 함께 저장
     > - 파이널이 아닌 변수를 포획한 경우 : 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 래퍼에 대한 참조를 람다 코드와 함께 저장

   - 람다를 이벤트 핸들러나 다른 비동기적으로 실행되는 코드로 활용하는 경우 함수 호출이 끝난 다음에 로컬 변수가 변경될 수도 있음

     ```kotlin
     // 버튼 클릭 개수를 정확히 셀 수 없음
     fun tryToCountButtonClicks(button: Button) : Int {
     		var clicks = 0
     		button.onClick { clicks++ }
     		return clicks
     }
     ```

5. **멤버 참조**

   - 함수를 값으로 바꿀 때 이중 콜론(::)을 사용

     ```kotlin
     val getAge = Person::age
     ```

   - 멤버 참조 : `::`를 사용하는 식

   - 멤버 참조는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어줌

   - `::`는 클래스 이름과 참조하려는 멤버 이름 사이에 위치

   - 참조 대상이 함수인지 프로퍼티인지와는 관계없이 멤버 참조 뒤에는 괄호를 넣으면 안됨

   - 멤버 참조는 그 멤버를 호출하는 람다와 같은 타입이어서 자유롭게 바꿔 쓸 수 있음

   - 멤버 참조는 최상위에 선언된 함수나 프로퍼티를 참조 가능

   - 람다가 인자가 여럿인 다름 함수한테 작업을 위임하는 경우 람다를 정의하지 않고 직접 위임 함수에 대한 참조를 제공하면 편리

   - 생성자 참조를 사용하면 클래스 생성 작업을 연기하거나 저장해둘 수 있음

     ```kotlin
     data class Person(val name: String, val age: Int)
     
     >>> val createPerson = ::Person
     >>> val p = createPerson("Alice", 29)
     ```

   - 확장 함수도 멤버 함수와 똑같은 방식으로 참조할 수 있음

</br>

## 5.2 컬렉션 함수형 API

1. **필수적인 함수: filter와 map**

   - `filter` 함수 : 컬렉션을 이터레이션하면서 주어진 람다에 각 원소를 넘겨서 람다가 `true`를 반환하는 원소만 모음

     ```kotlin
     fun main(args: Array<String>) {
         val people = listOf(Person("Alice", 29), Person("Bob", 31))
         println(people.filter { it.age > 30 })
     }
     ```

     > 원치 않는 원소는 제거하지만 원소를 변환할 수는 없음

   - `map` 함수 : 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만듬

     ```kotlin
     fun main(args: Array<String>) {
         val people = listOf(Person("Alice", 29), Person("Bob", 31))
         println(people.map { it.name })
     }
     ```

2. **all, any, count, find: 컬렉션에 술어 적용**

   - 술어 함수 예시

     ```kotlin
     val canBeInClub27 = { p: Person -> p.age <= 27 }
     ```

   - `all` 함수 : 모든 원소가 술어를 만족하는지 궁금하다면 사용

     ```kotlin
     val people = listOf(Person("Alice", 27), Person("Bob", 31))
     println(people.all(canBeInClub27))
     ```

   - `any` 함수 : 술어를 만족하는 원소가 하나라도 있는지 궁금하면 사용

     ```kotlin
     println(people.any(canBeInClub27))
     ```

   - `count` 함수 : 술어를 만족하는 원소의 개수 구할 때 사용

     ```kotlin
     println(people.count(canBeInClub27))
     ```

   - `find` 함수 : 술어를 만족하는 원소를 하나 찾고 싶으면 사용

     ```kotlin
     println(people.find(canBeInClub27))
     ```

     > 가장 먼저 조건을 만족한다고 확인된 원소를 반환
     >
     > 없으면 null을 반환

3. **groupBy: 리스트를 여러 그룹으로 이뤄진 맵으로 변경**

   - `groupBy` 함수 : 특성을 파라미터로 전달하면 컬렉션을 자동으로 구분해주는 함수

     ```kotlin
     println(people.groupBy { it.age })
     ```

     > 컬렉션의 원소를 구분하는 특성(age)이 키이고, 키 값에 따른 각 그룹이 값인 맵

   - 각 그룹은 리스트이기 때문에 `groupBy`의 결과 타입은 `Map<Int, List<Person>>`

4. **flatMap과 flatten: 중첩된 컬렉션 안의 원소 처리**

   - `flatMap` 함수 : 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모음

     ```kotlin
     fun main(args: Array<String>) {
         val strings = listOf("abc", "def")
         println(strings.flatMap { it.toList() })
     }
     
     // [a, b, c, d, e, f]
     ```

   - `flatten` 함수 : 리스트의 원소를 한 리스트로 모으는 경우가 아니고 특별히 변환해야 할 내용이 없을 때 사용

</br>

