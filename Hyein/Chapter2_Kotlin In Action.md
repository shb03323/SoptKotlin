# Kotlin In Action

## 2. 코틀린 기초

#### 2. 1 기본 요소: 함수와 변수

- **함수 & 변수** : 모든 프로그램을 구성하는 기본 단위



##### 2.1.1 Hello, World!

``````kotlin
fun main(args: Array<String>){
    println("Hello, world!")
}
``````

- 특성
  - 함수를 선언할 땐 `fun`키워드 사용
  - 파라미터 이름 뒤에 파라미터의 **타입**을 쓴다.
  - 함수를 최상위 수준에 정의 가능
  - **세미콜론(;)**을 붙이지 않아도 된다.



##### 1.1.2 함수

- **if**

  : 결과를 만드는 **식**

  :key: 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다.



- **식이 본문인 함수**

  - 블록이 본문인 함수 : 본문이 중괄호로 둘러싸인 함수

  - 식이 본문인 함수 : 등호와 식으로 이뤄진 함수

    :arrow_forward: 코틀린에서는 **식이 본문인 함수**가 자주 쓰인다.

    - 반환타입을 적지 않아도 *컴파일러*가 함수 본문 식을 분석, 식의 결과 타입을 함수 반환 타입으로 정해준다 :arrow_forward:  **타입추론**

      :warning: 식이 본문인 함수의 반환타입만 생략 가능, 블록이 본문인 함수가 값을 반환할 경우 	**return** 을 사용해 반환 값을 명시해야한다.

      

##### 2.1.3 변수

:warning: 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 **명시**

- **변경 가능한 변수와 변경 불가능한 변수**
  
  - **val**
    
    - 변경 불가능한 참조를 저장하는 변수
    
    - 초기화 하고 나면 재대입이 불가능하다
    
      :key: 참조 자체는 불변이나, 참고가 가리키는 객체의 내부 값은 변경될 수 있다
    
  - **var**
  
    - 변경 가능한 참조
    - 변수의 값이 바뀔 수 있다
  
    

##### 1.1.5 더 쉽게 문자열 형식 지정: 문자열 템플릿

- **문자열 텝플릿**

  :arrow_forward: 코틀린에서도 변수를 문자열 안에 사용할 수 있다.
  
  - `$` : 변수 앞에 추가하는 키워드, 문자열 템플릿 사용
  - `${}` : 변수나 식을 중괄호로 감쌀 수 있다
  
  

***



#### 1.2 클래스와 프로퍼티

- **값 객체** : 코드가 없이 데이터만 저장

``````kotlin
class Person(val name: String)
``````



##### 2.2.1 프로퍼티

- **프로퍼티**

  : 필드 * 접근자

  - 필드 : 데이터 저장
  - 접근자(메소드) : 데이터에 접근하는 통로 (게터, 세터)

  :arrow_forward:  코틀린은 프로퍼티를 언어 기본 기능으로 제공



- 클래스에서 프로퍼티 사용
  - 변수를 선언하는 방법과 마찬가지로 `val`과 `var`을 사용
    - val 선언 프로퍼티 : 읽기 전용
    - var 선언 프로퍼티 : 변경 가능



- **프로퍼티를 뒷받침 하는 필드**

  : 프로퍼티의 값을 저장하기 위한 필드

  :arrow_forward:  **커스텀 게터**를 통해 만들 수 있다.

  ``````kotlin
  class Rectangle(val height: Int, val width: Int) {
      val isSquare: Boolean
      	get() { // 프로퍼티 게터 선언
              return height == width
          }
  }
  ``````

  

##### 2.2.3 코틀린 소스코드 구조: 디렉터리와 패키지

- package

  : 코틀린 파일의 맨 앞에 package문을 넣어 파일 안에 있는 모든 선언(클래스, 함수, 프로퍼티 등)을 해당 패키지에 넣을 수 있다

  - package이름 뒤에 `.*`를 추가하면 패키지 안의 모든 선언을 임포트할 수 있다.

- import

  : 다른 패키지에 정의한 선언을 사용하기 위해 선언한다

  

***



#### 2.3 선택 표현과 처리: enum과 when

##### 2.3.1 enum 클래스 정의

- **enum**

  ``````kotlin
  enum class Color{
      RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
  }
  ``````

  - 소프트 키워드
  - 단순히 값만 열거하는 것이 아닌 프로퍼티나 메소드 등도 정의할 수 있다.

  ``````kotlin
  enum class Color (
  	val r: Int, val g: Int, val b: Int
  ) {
      RED(255,0, 0), ORANGE(255,165, 0),
      YELLOW(255,255, 0), GREEN(0, 255, 0), BLUE(0, 0, 255),
      INDIGO(75,0, 130), VIOLET(238,130, 238);
      
      fun rgb() = (r * 256 + g) * 256 + b
  }
  ``````

  - **코틀린에서 유일하게 세미콜론이 필수인 부분**

    :arrow_forward: 상수목록과 메소드 정의 사이



##### 2.3.2 when으로 enum 클래스 다루기

- **when**

  : switch에 해당하는 코틀린 구성요소

  - **값을 만들어 내는 식**
  - **break**를 넣지 않아도 된다.
  - 한 분기 안에 여러 패턴을 사용할 경우 , 로 구분



##### 2.3.3 when과 임의의 객체를 함께 사용

- 코틀린의 when의 분기 조건은 임의의 객체를 허용한다.

  ``````kotlin
  fun mix(c1: Color, c2: Color) =
  	when (sefOf(c1, c2)){
          setOf(RED, YELLOW) -> ORANGE
          setOf(YELLOW, BLUE) -> GREEN
          setOf(BLUE, VIOLET) -> INDIGO
          else -> throw Exception("Dirty color")
      }
  ``````

  - `Set` : 원소가 모여있는 컬렉션, 각 원소의 순서는 중요하지 않다.
    - `setOf`로 선언한다.
  - 위 코드는 **조건에서 동등성을 검사**했다.



##### 2.3.4 인자없는 when 사용

- 인자가 없는 when 식을 사용하면 불필요한 객체(가비지 객체) 생성을 막을 수 있다.

  :key: 각 분기의 조건이 **Boolean** 결과를 계산하는 식이여야 한다



##### 2.3.5

- `Expr` : 아무 메소드도 선언하지 않으며, 단지 여러 타입의 식 객체를 아우르는 공통 타입 역할 수행

- `is`

  : 변수 타입 검사

- **스마트 캐스트**

  : 어떤 타입인지 검사하고 나면 캐스팅 하지 않아도 처음부터 그 분셔가 원하는 타입으로 선언된 것 처럼 사용할 수 있다.

  :arrow_forward: 실제로는 컴파일러가 수행

  - is로 변수에 든 값의 타입을 검사한 다음에 그 값이 바뀔 수 없는 경우에만 작동한다

    - 반드시 **val**

    - `as` : 원하는 타입으로 명시적 타입 캐스팅



##### 2.3.6 리팩토링: if를 when으로 변경

``````kotlin
fun eval(e: Expr) : Int =
	when (e) {
        is Num ->
        	e.value
        is Sum ->
        	eval(e.right) + eval(e.left)
        else ->
        	throw IllegalArgumentException("Unknown expression")
    }
``````

- when식을 동등성 검사가 아닌 다른 기능에도 쓸 수 있다.



##### 2.3.7 if와 when의 분기에서 블록 사용

:key: 블록의 마지막 문장이 **블록의 전체의 결과**



***



#### 2.4 대상을 이터레이션: while과 for 루프

##### 2.4.1 while 루프

- while
- do-while



##### 2.4.2 수에 대한 이터레이션: 범위와 수열

- **for**

  - 범위

    - 루프의 가잔 흔한 용례인 초깃값, 증가값, 최종값을 사용한 루프를 대신하기 위해 사용
    - `..` 연산자로 시작 값과 끝 값을 연결하여 범위를 만든다.
      - 폐구간

  - 수열

    : 어떤 범위에 속한 값을 일정한 순서로 이터레이션 하는 경우

    ``````kotlin
    for (i in 100 downTo 1 step 2) {
        print(fizzBuzz(i))
    }
    ``````

    - `step` : 증가 값
      - 음수 값을 통해 역방향 수열을 만들 수 있다.
    - `downTo` : 역방향 수열

  - `until`

    : 끝 값을 포함하지 않는 반만 닫힌 범위



##### 2.4.3 맵에 대한 이터레이션

- `..` 연산자를 숫자 타입의 값 뿐 아니라 문자 타입의 값에도 적용할 수 있다.

  :arrow_forward: 컬렉션이나 범위에 대해 in 키워드 사용 가능

- **map**

  - map[key] : 값을 의미 (get)
  - map[key] = value : 값을 설정 (set)



##### 2.4.4 in으로 컬렉션이나 범위의 원소 검사

- `in`

  :arrow_forward: 어떤 값이 범위에 속하는 지 검사할 수 있다.

  - `!in` : 어떤 값이 범위에 속하지 않는지 검사 가능
  - 범위는 문자에만 국한 :x:
    - 비교가 가능한 클래스라면 그 클래스의 인스턴스 객체를 사용해 범위를 만들 수 있다.



***



#### 2.5 코틀린의 예외 처리

- 오류가 발생 :arrow_forward: 함수는 예외를 throw (던질 수 있다)
- 예외를 처리 :arrow_forward: 함수를 호출한 쪽은 ​예외릘 잡아 catch(처리)할 수 있다.
- 처리하지 않으면 :arrow_forward: 함수 호출 스택을 거슬러 올라가면서 예외를 처리하는 부분이 나올 때 까지 예외를 throw(던진다)
  - `throw` 는 식이다.



##### 2.5.1 try, catch, finally

- 예외 처리를 위해 try, catch, finally를 사용한다.

- 자바

  - **체크 예외 명시적 처리**

    :arrow_forward: 함수를 작성할 때 함수 선언 뒤에 throws IOException을 붙여야 한다.​

    - IOException은 체크 예외이다.

- 코틀린

  - **체크 예외와 언체크 예외를 구별하지 않는다**



##### 2.5.2 try를 식으로 사용

:key: try의 본문은 반드시 중괄호 {} 로 둘러싸야 하며 마지막 식의 값이 전체 결과 값이다.